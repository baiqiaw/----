# 认证授权机制设计文档

## 版本信息

| 版本号 | 编制日期 | 修订说明 | 编制人 |
| ---- | ----------- | ---- | ----- |
| V1.0 | 2025 年 11 月 | 初始版本 | 安全工程师 |

## 1. 文档说明

### 1.1 文档目的

本文档详细设计文档转换工具系统的认证授权机制，包括Bearer Token + API Key双重认证的实现方案、权限控制、安全措施等，为系统安全提供保障。

### 1.2 适用范围

本文档适用于：

- 安全工程师
- 后端开发人员
- API接口开发人员
- 系统架构师

### 1.3 参考文档

- 《文档转换工具需求规格说明书（SRS）》
- 《RESTful API规范设计文档》
- 《错误处理机制详细设计文档（DDD）》
- 《API错误码定义文档》

---

## 2. 认证授权概述

### 2.1 认证授权架构

系统采用**双重认证机制**：

1. **Bearer Token认证**：用于用户身份认证
2. **API Key认证**：用于API访问授权

### 2.2 设计原则

- **安全性**：采用业界标准的安全机制
- **可扩展性**：支持多种认证方式
- **易用性**：提供简单的集成方式
- **可审计性**：记录所有认证和授权操作

### 2.3 认证流程

```text
1. 用户登录 → 获取Access Token和Refresh Token
2. 获取API Key（企业版用户）
3. 使用Token + API Key访问API
4. Token过期 → 使用Refresh Token刷新
5. API Key过期 → 重新获取API Key
```

---

## 3. Token认证机制

### 3.1 JWT Token设计

#### 3.1.1 Token结构

系统使用JWT（JSON Web Token）作为Token格式：

```typescript
interface JWTPayload {
  // 标准声明
  iss: string;          // 签发者（Issuer）
  sub: string;          // 主题（Subject，用户ID）
  aud: string;          // 受众（Audience）
  exp: number;          // 过期时间（Expiration Time）
  iat: number;          // 签发时间（Issued At）
  jti: string;          // JWT ID（唯一标识）
  
  // 自定义声明
  userId: string;       // 用户ID
  username: string;    // 用户名
  email: string;        // 邮箱
  role: string;         // 用户角色
  permissions: string[]; // 权限列表
  accountType: string;  // 账户类型（free/basic/enterprise）
}
```

#### 3.1.2 Token类型

| Token类型 | 用途 | 有效期 | 刷新机制 |
| ---- | ---- | ---- | ---- |
| Access Token | 访问API | 1小时 | 使用Refresh Token刷新 |
| Refresh Token | 刷新Access Token | 7天 | 重新登录获取 |

#### 3.1.3 Token签名

- **算法**：HS256（HMAC SHA-256）
- **密钥**：使用环境变量配置，定期轮换
- **密钥管理**：使用密钥管理服务（KMS）或环境变量

### 3.2 Token生成

#### 3.2.1 生成流程

```typescript
/**
 * 生成Access Token
 */
function generateAccessToken(user: User): string {
  const payload: JWTPayload = {
    iss: 'document-converter-api',
    sub: user.id,
    aud: 'document-converter-client',
    exp: Math.floor(Date.now() / 1000) + 3600, // 1小时后过期
    iat: Math.floor(Date.now() / 1000),
    jti: generateUUID(),
    userId: user.id,
    username: user.username,
    email: user.email,
    role: user.role,
    permissions: user.permissions,
    accountType: user.accountType,
  };
  
  return jwt.sign(payload, JWT_SECRET, { algorithm: 'HS256' });
}

/**
 * 生成Refresh Token
 */
function generateRefreshToken(user: User): string {
  const payload = {
    userId: user.id,
    type: 'refresh',
    exp: Math.floor(Date.now() / 1000) + 7 * 24 * 3600, // 7天后过期
    iat: Math.floor(Date.now() / 1000),
    jti: generateUUID(),
  };
  
  return jwt.sign(payload, REFRESH_TOKEN_SECRET, { algorithm: 'HS256' });
}
```

### 3.3 Token验证

#### 3.3.1 验证流程

```typescript
/**
 * 验证Token
 */
function verifyToken(token: string): JWTPayload | null {
  try {
    const decoded = jwt.verify(token, JWT_SECRET, {
      algorithms: ['HS256'],
      issuer: 'document-converter-api',
      audience: 'document-converter-client',
    }) as JWTPayload;
    
    // 检查Token是否在黑名单中
    if (await isTokenBlacklisted(decoded.jti)) {
      return null;
    }
    
    return decoded;
  } catch (error) {
    return null;
  }
}
```

#### 3.3.2 验证中间件

```typescript
/**
 * Token验证中间件
 */
async function authenticateToken(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
  
  if (!token) {
    return res.status(401).json({
      success: false,
      error: {
        code: 'E00003',
        message: '未认证',
      },
    });
  }
  
  const payload = verifyToken(token);
  if (!payload) {
    return res.status(401).json({
      success: false,
      error: {
        code: 'E06003',
        message: 'Token无效',
      },
    });
  }
  
  // 将用户信息附加到请求对象
  req.user = payload;
  next();
}
```

### 3.4 Token刷新

#### 3.4.1 刷新流程

```typescript
/**
 * 刷新Token
 */
async function refreshToken(refreshToken: string): Promise<{
  accessToken: string;
  refreshToken: string;
} | null> {
  try {
    // 验证Refresh Token
    const decoded = jwt.verify(
      refreshToken,
      REFRESH_TOKEN_SECRET
    ) as RefreshTokenPayload;
    
    // 检查Refresh Token是否在黑名单中
    if (await isTokenBlacklisted(decoded.jti)) {
      return null;
    }
    
    // 获取用户信息
    const user = await getUserById(decoded.userId);
    if (!user) {
      return null;
    }
    
    // 生成新的Token
    const newAccessToken = generateAccessToken(user);
    const newRefreshToken = generateRefreshToken(user);
    
    // 将旧的Refresh Token加入黑名单
    await blacklistToken(decoded.jti);
    
    return {
      accessToken: newAccessToken,
      refreshToken: newRefreshToken,
    };
  } catch (error) {
    return null;
  }
}
```

### 3.5 Token黑名单

#### 3.5.1 黑名单机制

- **用途**：记录已注销的Token，防止Token被滥用
- **存储**：使用Redis存储，TTL与Token过期时间一致
- **清理**：自动清理过期的Token记录

```typescript
/**
 * 将Token加入黑名单
 */
async function blacklistToken(jti: string, expiresIn: number): Promise<void> {
  await redis.setex(`token:blacklist:${jti}`, expiresIn, '1');
}

/**
 * 检查Token是否在黑名单中
 */
async function isTokenBlacklisted(jti: string): Promise<boolean> {
  const result = await redis.get(`token:blacklist:${jti}`);
  return result !== null;
}
```

---

## 4. API Key认证机制

### 4.1 API Key设计

#### 4.1.1 API Key格式

```typescript
interface APIKey {
  keyId: string;         // Key ID（用于标识）
  keyValue: string;      // Key值（用于认证）
  userId: string;        // 用户ID
  name: string;          // Key名称（用户自定义）
  permissions: string[]; // 权限列表
  createdAt: Date;      // 创建时间
  expiresAt?: Date;      // 过期时间（可选）
  lastUsedAt?: Date;     // 最后使用时间
  isActive: boolean;    // 是否激活
}
```

#### 4.1.2 API Key生成

```typescript
/**
 * 生成API Key
 */
function generateAPIKey(userId: string, name: string): APIKey {
  const keyId = generateUUID();
  const keyValue = generateSecureRandomString(32); // 32位随机字符串
  
  // 对Key值进行哈希存储
  const hashedKey = hashAPIKey(keyValue);
  
  return {
    keyId,
    keyValue, // 只返回一次，后续不再返回
    userId,
    name,
    permissions: [],
    createdAt: new Date(),
    expiresAt: null,
    isActive: true,
  };
}
```

### 4.2 API Key存储

#### 4.2.1 存储策略

- **Key值**：使用哈希存储（SHA-256），不存储明文
- **Key ID**：明文存储，用于快速查找
- **存储位置**：数据库（PostgreSQL）

```typescript
interface APIKeyRecord {
  keyId: string;
  hashedKey: string;     // 哈希后的Key值
  userId: string;
  name: string;
  permissions: string[];
  createdAt: Date;
  expiresAt?: Date;
  lastUsedAt?: Date;
  isActive: boolean;
}
```

### 4.3 API Key验证

#### 4.3.1 验证流程

```typescript
/**
 * 验证API Key
 */
async function verifyAPIKey(apiKey: string): Promise<APIKeyRecord | null> {
  // 从请求头获取API Key
  // 格式：X-API-Key: {api_key}
  
  // 对API Key进行哈希
  const hashedKey = hashAPIKey(apiKey);
  
  // 从数据库查找
  const keyRecord = await db.query(
    'SELECT * FROM api_keys WHERE hashed_key = $1 AND is_active = true',
    [hashedKey]
  );
  
  if (!keyRecord || keyRecord.length === 0) {
    return null;
  }
  
  const record = keyRecord[0];
  
  // 检查是否过期
  if (record.expiresAt && record.expiresAt < new Date()) {
    return null;
  }
  
  // 更新最后使用时间
  await updateAPIKeyLastUsed(record.keyId);
  
  return record;
}
```

#### 4.3.2 验证中间件

```typescript
/**
 * API Key验证中间件
 */
async function authenticateAPIKey(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  const apiKey = req.headers['x-api-key'] as string;
  
  if (!apiKey) {
    return res.status(401).json({
      success: false,
      error: {
        code: 'E08011',
        message: 'API Key缺失',
      },
    });
  }
  
  const keyRecord = await verifyAPIKey(apiKey);
  if (!keyRecord) {
    return res.status(401).json({
      success: false,
      error: {
        code: 'E08012',
        message: 'API Key无效',
      },
    });
  }
  
  // 将API Key信息附加到请求对象
  req.apiKey = keyRecord;
  next();
}
```

### 4.4 API Key管理

#### 4.4.1 创建API Key

**接口**：`POST /api/v1/auth/api-keys`

**请求**：

```json
{
  "name": "生产环境API Key",
  "permissions": ["convert", "batch"],
  "expiresAt": "2026-11-15T10:30:00Z"
}
```

**响应**：

```json
{
  "success": true,
  "data": {
    "keyId": "key_1234567890",
    "keyValue": "sk_live_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
    "name": "生产环境API Key",
    "createdAt": "2025-11-15T10:30:00Z",
    "expiresAt": "2026-11-15T10:30:00Z",
    "warning": "请妥善保管API Key，它只会显示一次"
  }
}
```

#### 4.4.2 查询API Key列表

**接口**：`GET /api/v1/auth/api-keys`

**响应**：

```json
{
  "success": true,
  "data": [
    {
      "keyId": "key_1234567890",
      "name": "生产环境API Key",
      "permissions": ["convert", "batch"],
      "createdAt": "2025-11-15T10:30:00Z",
      "expiresAt": "2026-11-15T10:30:00Z",
      "lastUsedAt": "2025-11-15T12:00:00Z",
      "isActive": true
    }
  ]
}
```

#### 4.4.3 删除API Key

**接口**：`DELETE /api/v1/auth/api-keys/{key_id}`

**响应**：

```json
{
  "success": true,
  "data": {
    "message": "API Key已删除"
  }
}
```

#### 4.4.4 重置API Key

**接口**：`POST /api/v1/auth/api-keys/{key_id}/reset`

**响应**：

```json
{
  "success": true,
  "data": {
    "keyId": "key_1234567890",
    "keyValue": "sk_live_new_xxxxxxxxxxxxxxxxxxxxxxxxxxxx",
    "warning": "请妥善保管新的API Key，旧的API Key已失效"
  }
}
```

---

## 5. 权限控制（RBAC）

### 5.1 角色定义

| 角色 | 说明 | 权限 |
| ---- | ---- | ---- |
| admin | 系统管理员 | 所有权限 |
| enterprise_admin | 企业管理员 | 企业内所有权限 |
| enterprise_user | 企业用户 | 文件转换、批量处理 |
| basic_user | 基础用户 | 文件转换（有限制） |
| free_user | 免费用户 | 文件转换（严格限制） |

### 5.2 权限定义

| 权限 | 说明 | 适用角色 |
| ---- | ---- | ---- |
| convert:single | 单文件转换 | 所有用户 |
| convert:batch | 批量转换 | enterprise_user, basic_user |
| convert:unlimited | 无限制转换 | enterprise_user |
| file:upload | 文件上传 | 所有用户 |
| file:download | 文件下载 | 所有用户 |
| file:delete | 文件删除 | enterprise_user |
| ocr:recognize | OCR识别 | enterprise_user, basic_user |
| ai:assist | AI辅助 | enterprise_user |
| user:manage | 用户管理 | admin, enterprise_admin |
| api:manage | API管理 | enterprise_user |

### 5.3 权限检查

#### 5.3.1 权限检查中间件

```typescript
/**
 * 权限检查中间件
 */
function requirePermission(permission: string) {
  return (req: Request, res: Response, next: NextFunction) => {
    const user = req.user;
    const apiKey = req.apiKey;
    
    // 检查用户权限
    if (user && user.permissions.includes(permission)) {
      return next();
    }
    
    // 检查API Key权限
    if (apiKey && apiKey.permissions.includes(permission)) {
      return next();
    }
    
    return res.status(403).json({
      success: false,
      error: {
        code: 'E00004',
        message: '权限不足',
      },
    });
  };
}

// 使用示例
app.post('/api/v1/convert',
  authenticateToken,
  authenticateAPIKey,
  requirePermission('convert:single'),
  convertHandler
);
```

### 5.4 资源级权限

#### 5.4.1 资源所有权检查

```typescript
/**
 * 检查资源所有权
 */
async function checkResourceOwnership(
  userId: string,
  resourceType: string,
  resourceId: string
): Promise<boolean> {
  switch (resourceType) {
    case 'file':
      const file = await getFileById(resourceId);
      return file && file.userId === userId;
    case 'task':
      const task = await getTaskById(resourceId);
      return task && task.userId === userId;
    default:
      return false;
  }
}

/**
 * 资源所有权检查中间件
 */
function requireResourceOwnership(resourceType: string) {
  return async (req: Request, res: Response, next: NextFunction) => {
    const userId = req.user.userId;
    const resourceId = req.params.id;
    
    const isOwner = await checkResourceOwnership(
      userId,
      resourceType,
      resourceId
    );
    
    if (!isOwner) {
      return res.status(403).json({
        success: false,
        error: {
          code: 'E00004',
          message: '权限不足',
        },
      });
    }
    
    next();
  };
}
```

---

## 6. 安全措施

### 6.1 密码安全

#### 6.1.1 密码存储

- **哈希算法**：bcrypt（cost factor: 12）
- **盐值**：自动生成，每个密码使用不同的盐值
- **存储**：仅存储哈希值，不存储明文

```typescript
/**
 * 密码哈希
 */
async function hashPassword(password: string): Promise<string> {
  const saltRounds = 12;
  return await bcrypt.hash(password, saltRounds);
}

/**
 * 密码验证
 */
async function verifyPassword(
  password: string,
  hashedPassword: string
): Promise<boolean> {
  return await bcrypt.compare(password, hashedPassword);
}
```

#### 6.1.2 密码策略

- **最小长度**：8个字符
- **复杂度要求**：至少包含大小写字母、数字、特殊字符中的三种
- **密码历史**：不能使用最近5次使用过的密码
- **密码过期**：90天（企业版可配置）

### 6.2 传输安全

#### 6.2.1 HTTPS强制

- 所有API请求必须使用HTTPS
- HTTP请求自动重定向到HTTPS
- 使用TLS 1.2或更高版本

#### 6.2.2 敏感信息保护

- Token和API Key不在URL中传递
- 敏感信息不在日志中记录
- 使用加密传输

### 6.3 防护措施

#### 6.3.1 防止暴力破解

- **登录限制**：5次失败后锁定账户15分钟
- **API Key限制**：10次失败后临时封禁1小时
- **IP限制**：同一IP频繁失败后临时封禁

```typescript
/**
 * 检查登录尝试
 */
async function checkLoginAttempts(
  identifier: string,
  ip: string
): Promise<boolean> {
  const key = `login:attempts:${identifier}:${ip}`;
  const attempts = await redis.incr(key);
  
  if (attempts === 1) {
    await redis.expire(key, 900); // 15分钟
  }
  
  if (attempts > 5) {
    return false; // 超过限制
  }
  
  return true;
}
```

#### 6.3.2 防止Token泄露

- Token不在URL中传递
- Token不在日志中记录
- 使用HttpOnly Cookie（Web应用）
- 定期轮换密钥

#### 6.3.3 防止重放攻击

- 使用JWT的`jti`（JWT ID）防止重放
- 记录已使用的Token ID
- 设置合理的Token过期时间

### 6.4 审计日志

#### 6.4.1 日志记录

记录以下操作：

- 登录/登出
- Token刷新
- API Key创建/删除
- 权限变更
- 敏感操作

```typescript
/**
 * 记录审计日志
 */
async function logAuditEvent(event: AuditEvent): Promise<void> {
  await db.insert('audit_logs', {
    userId: event.userId,
    action: event.action,
    resource: event.resource,
    ip: event.ip,
    userAgent: event.userAgent,
    timestamp: new Date(),
    details: event.details,
  });
}
```

---

## 7. 认证接口设计

### 7.1 用户登录

**接口**：`POST /api/v1/auth/login`

**请求**：

```json
{
  "username": "user@example.com",
  "password": "password123"
}
```

**响应**：

```json
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "refresh_token_xxx",
    "tokenType": "Bearer",
    "expiresIn": 3600,
    "user": {
      "userId": "user_123456",
      "username": "user@example.com",
      "email": "user@example.com",
      "role": "enterprise_user",
      "accountType": "enterprise"
    }
  }
}
```

### 7.2 Token刷新

**接口**：`POST /api/v1/auth/refresh`

**请求**：

```json
{
  "refreshToken": "refresh_token_xxx"
}
```

**响应**：

```json
{
  "success": true,
  "data": {
    "accessToken": "new_access_token_xxx",
    "refreshToken": "new_refresh_token_xxx",
    "expiresIn": 3600
  }
}
```

### 7.3 用户登出

**接口**：`POST /api/v1/auth/logout`

**请求头**：

```http
Authorization: Bearer {token}
```

**响应**：

```json
{
  "success": true,
  "data": {
    "message": "登出成功"
  }
}
```

### 7.4 获取当前用户信息

**接口**：`GET /api/v1/auth/me`

**请求头**：

```http
Authorization: Bearer {token}
X-API-Key: {api_key}
```

**响应**：

```json
{
  "success": true,
  "data": {
    "userId": "user_123456",
    "username": "user@example.com",
    "email": "user@example.com",
    "role": "enterprise_user",
    "accountType": "enterprise",
    "permissions": ["convert:single", "convert:batch"],
    "apiKeys": [
      {
        "keyId": "key_1234567890",
        "name": "生产环境API Key",
        "createdAt": "2025-11-15T10:30:00Z"
      }
    ]
  }
}
```

---

## 8. 实现细节

### 8.1 中间件组合

```typescript
// 需要Token和API Key的接口
app.post('/api/v1/convert',
  authenticateToken,
  authenticateAPIKey,
  requirePermission('convert:single'),
  convertHandler
);

// 仅需要Token的接口
app.get('/api/v1/auth/me',
  authenticateToken,
  getCurrentUserHandler
);

// 公开接口（无需认证）
app.get('/api/v1/system/status',
  getSystemStatusHandler
);
```

### 8.2 错误处理

```typescript
/**
 * 认证错误处理
 */
function handleAuthError(error: Error, req: Request, res: Response) {
  if (error.name === 'TokenExpiredError') {
    return res.status(401).json({
      success: false,
      error: {
        code: 'E06002',
        message: 'Token过期',
      },
    });
  }
  
  if (error.name === 'JsonWebTokenError') {
    return res.status(401).json({
      success: false,
      error: {
        code: 'E06003',
        message: 'Token无效',
      },
    });
  }
  
  return res.status(500).json({
    success: false,
    error: {
      code: 'E00001',
      message: '系统内部错误',
    },
  });
}
```

---

## 9. 最佳实践

### 9.1 Token使用

- **存储**：客户端安全存储Token（内存或安全存储）
- **传输**：始终使用HTTPS传输Token
- **刷新**：在Token过期前主动刷新
- **注销**：登出时将Token加入黑名单

### 9.2 API Key使用

- **保管**：API Key只显示一次，妥善保管
- **权限**：遵循最小权限原则
- **轮换**：定期轮换API Key
- **监控**：监控API Key使用情况

### 9.3 安全建议

- 使用强密码
- 启用双因素认证（2FA）
- 定期更新密钥
- 监控异常登录
- 及时处理安全事件

## 10. 附录

### 10.1 术语表

- **JWT**：JSON Web Token，一种开放标准（RFC 7519）
- **RBAC**：Role-Based Access Control，基于角色的访问控制
- **2FA**：Two-Factor Authentication，双因素认证
- **KMS**：Key Management Service，密钥管理服务

### 10.2 参考资源

- [JWT规范](https://tools.ietf.org/html/rfc7519)
- [OAuth 2.0规范](https://oauth.net/2/)
- [OWASP认证指南](https://owasp.org/www-project-authentication-cheat-sheet/)

---

## 更新记录

| 版本号 | 更新日期 | 更新内容 | 更新人 |
| ---- | ---- | ---- | ---- |
| V1.0 | 2025 年 11 月 | 初始版本 | 安全工程师 |
